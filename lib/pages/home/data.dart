import 'dart:math';
import 'package:my_blog/pages/home/essay.dart';


List<String> contents = [
  """
Getting Started
First,download dependency
```bash
yarn
```
Second, run the development server:

```bash
yarn start
```

## 项目介绍

此项目为‘跨六端博客’的web前端，负责大屏、中大屏的web渲染展示，作为小屏端、Android、ios端flutter项目的互补项目，利用了大量的动画、交互、视觉效果，以及一些新的技术，使用户体验更加流畅，更加美观，更加人性化。

## 项目实现

### 技术选型与相关开发文档

- web端渲染框架umi.js
- 开发语言 Typescript
- Git提交规范
    - husky + commitizen
- 代码规范及格式
    - eslint + @antfu/eslint-config
    - Prettier (未格式样式可使用Prettier 插件格式)
- CSS
    - 样式重置 normalize.css
    - CSS 框架 less
- 组件库
    - And Design of React
- 网络请求
    - Axios
    - umi-request
- 其他三方库
    - react-markdown -> markdown解析
    - classnames -> 处理class
    - javascript-time-ago -> 格式化时间
    - less & less-loader & postcss-less -> 处理less
    - lodash-es -> 工具函数库

### 架构设计

1. 规范制定：制定了一套统一的代码规范，并使用eslint等工具，以提高代码质量和协作效率
2. 模块化：为了实现高内聚低耦合的设计原则并且提升协作效率，我们将业务分解为了多个独立的模块
3. 多页面同时需要的组件放入components下的一级文件夹(例如: components/Author, components/banner以及components/common下
   实现复用)
4. 页面组件下的组件放在以以页面为名称的文件夹下保证可扩展性
    1. 使用命名空间导出,确保可读性
5. 布局统一放在 /components/layout下以保证复用性
6. 组件拆分及管理：针对已划分的各个不同模块，我们进一步的对每一个模块进行了拆分，并且将可复用的 UI 元素封装为组件

### 项目代码介绍

```angular2html
juejin_by_sos-team
├── README.md
├── .husky
├── .editorconfig
├── .eslintrc.json
├── commitlint.config.js
├── declaration.d.ts
├── package-lock.json
├── package.json
├── public
│   ├── font               # 静态字体资源
├── config                 # umi配置（路由、代理等）
├── src
│   ├── assets               # 静态资源
│   ├── components           # 通用业务组件
│   ├── layout               # 布局
│   ├── pages                # 页面模版
│   ├── services             # 接口
│   ├── models               # redux状态管理
│   └── utils                # 工具库
│   └── constants            # 常量
│   └── wrappers             # 权限校验
└── tsconfig.json
```
  """,

  """
引言
3月份chatGPT是不安分的、微软是不安分的、那么勇哥就应该安分？不可能，绝对不可能。简单来说，勇哥3月份成功的把chatGPT3.5集成到bg-tinkle软件中发布了v1.0.5版本。集成后的bg-tinkle对于数据库的修改、统计、删除等操作就都是一句话的事了，非常NICE。

阅读本文你会了解3月份chatGPT重大的事件，体验如何使用AI帮助数据库优化、设计SQL等操作？以及了解本功能开发实现的思路？

事件回顾：不安分的3月大事
chatGPT竞品出现：（谷歌的）Bard、（百度的）文心一言

chatGPT发布新版：chatGPT4隆重发布（但是勇哥并不CARE，因为太贵和没资格）

chatGPT成品出现：微软office正式接入chatGPT，写好word、ppt、excel再也不用报班学习了（但是价格不便宜呀~）

数据库+AI：功能体验
AI功能是以聊天的方式进行，然后对聊天的结果可直接执行SQL、制作图表得操作。

通过数据库软件，直接获取数据库表结构，然后再此基础上可用让AI帮您设计统计分析、修改、优化等，并直接生成SQL语句。然后可在结果中一键执行SQL、或者生成SQL的统计图。


AI补全表注释
忘记写注释也不用怕，一键让AI补充+一键运行，10秒不到完成工作！大赞~


AI设计表索引
可以发送表常用的SQL语句，然后让其设计合理的索引。其设计的索引还挺符合行业规范的。大赞~


AI创建新表
依据现有的数据库，参考设计一张新的表。分成多次会话沟通，依然没有问题。

  """,


  """
 1.数据归约
在实际应用中,数据仓库可能存有海量数据,在全部数据上进行复杂的数据分析和挖掘工作所消耗的时间和空间成本巨大,这就催生了对数据进行归约的需求。

数据归约可以从几个方面入手:

如果对数据的每个维度的物理意义很清楚,就可以舍弃某些无用的维度,并使用平均值、汇总和计数等方式来进行聚合表示，这种方式称为数据立方体聚合;
如果数据只有有些维度对数据挖掘有益，就可以去除不重要的维度,保留对挖掘有帮助的维度,这种方式称为维度归约;如果数据具有潜在的相关性,那么数据实际的维度可能并不高，可以用变换的方式,用低维的数据对高维数据进行近似的表示，这种方式称为数据压缩;
另外一种处理数据相关性的方式是将数据表示为不同的形式来减小数据量,如聚类、回归等,这种方式称为数据块消减。


归约后：



1.1数据立方体聚合
数据立方体是一种数据表示和分析的工具,它将数据表示为多维的矩阵,可以对数据进行聚合运算如计数、求和和求平均值等操作。

1.2特征选择
特征选择在数据预处理和迭代调整的学习中都有较多的使用，目的是对于给定数据挖掘任务,选择效果较好的较小特征集合。

在预处理中，特征选择通常希望能使得在选择出的特征集合下的类别的概率分布能够尽量接近于在全部特征下的类别的概率分布，这是为了权衡空间复杂度、时间复杂度和数据挖掘效果的折中。

在原始的特征有N维的情况下,特征子集的可能情况有2^N种情形

通常使用启发式的特征选择方法如:

前向特征选择是通过选择新的特征添加到特征集合中,使得扩充后的特征集合具有更好的特性。
后向特征消减是通过从特征集合中取出最差的特征,使得新的特征集合具有更好的特性。
决策树归纳方法进行特征选择是借助决策树构建来选择较小特征集合的方法。
1.3数据压缩
数据压缩是在尽量保存原有数据中信息的基础上,用尽量少的空间表示原有的数据。数据压缩分为有损压缩和无损压缩,

有损压缩后的数据信息量少于原有的数据，因而无法完全恢复成原有的数据，只能以近似的方式恢复。

无损压缩没有这限制,从压缩后的数据可以完全恢复原有数据。无损压缩一般用于字符串的压缩，被广泛应用在文本文件的压缩中。【霍夫曼提出的具有理论意义的Huffman编码，以及广泛使用于gzip,deflate 等软件中的LZW算法】

在图像和音视频压缩中通常使用有损压缩，在图像压缩中常见的离散小波变换就是一种有损压缩，仅仅保存很少一部分较强的小波分量，可以在图像质量无明显下降的情况下获得相当高的压缩率。

主成分分析(PCA)是一种正交线性变换，它将数据通过正交变换到新的坐标系中,其中第一个分量有最大的方差，第二个分量有第二大的方差，依此类推，数据主要的能量集中在前几个分量中。【通常在处理维数较多的数值型数据中进行应用】

1.4其他数据归约方法
参数式方法和非参数式方法

回归分析
回归分析是一种典型的参数式方法,回归分析的一般表达式如下:



其中,F为模型的表达式,X为自变量,Y为因变量,β为模型的未知参数,E为误差,X、Y、β、E都可以是标量或矢量。回归分析的目的就是在一定条件下估计最好的参数β。根据不同

直方图


聚类
聚类是根据数据相似性将数据聚成簇的方法



简单随机采样（SAS）
随机地从所有N个数据中抽取M个数据,简单随机采样分为有放回的简单随机采样(SRSWR)和无放回的简单随机采样(SRSWOR),两者的差别在于从总体数据中拿出一个数据后,是否将这个数据放回。

2.数据离散化
计算机存储器无法存储无限精度的值，计算机处理器也不能对无限精度的数进行处理，因此在数据预处理中需要进行数据的离散化。另外，某些数据挖掘方法需要离散值的属性，这也催生了对数据进行离散化的需要。

通常每种方法都假定待离散化的值已经控递增序排序

2.1基于信息增益的离散化
在进行数据离散化的过程中，如果关注点主要在于属性值的离散化能够有助于提高分类的准确性，那么可以使用信息增益来进行数据离散化。这种离散化方法是一种自顶向下的拆分方法。

2.2基于卡方检验的离散化
卡方检验是通过两个变量的联合分布来衡量它们是否独立的一种统计工具。在数据离散化中也可以引入这种思想，对于一个属性的两个相邻的取值区间，“属性值处于哪一个的区间”与“数据属于哪一个类别”这两个变量的独立性可以表明是否应该合并两个区间。如果两个变量独立，那么属性值在哪个区间是不影响分类的，意味着这两个区间可以合并。因此可以提出如下自底向上的区间合并算法来对数据进行离散化：每次寻找相关性最小的两个相邻区间进行合并，循环运行直到停止条件。

2.3基于自然分区的离散化
在实际问题中有时也会采用一些经验性的方法，如自然分区法，即3-4-5规则。这种方法将数值型的数据分成相对规整的自然分区。

规则如下：

(1)如果一个区间包含的不同值的数量的最高有效位是3，6，7或9，将该区间等宽地分为3个区间；
(2)如果最高有效位是2，4或8，将该区间等宽地分为4个区间；
(3)如果最高有效位是1，5或10，将该区间等宽地分为5个区间。
3.概念层次生成
由用户或专家在模式级显式地说明属性的偏序
  """,

  """
  大致流程：问题分析（需求分析）,数据预处理（数据清洗，数据集成，数据归约），特征选择，模型选择（方案设计），模型求解，模型评估，模型解释，写成报告形式，展示。
先撇开问题分析不说，数据预处理是数据分析挖掘最重要也是最基本的步骤。因为数据的质量往往能决定结果的质量。所以本篇先不谈各种数据挖掘算法，先做好数据预处理的基本功才是最重要的。

只做总结，不作细说

一、认识数据
首先对数据进行一些基本的描述性统计分析。
1.数据基本统计描述
关于中心趋势度量：均值，中位数，众数，中列数
给定一个属性，看他的值大部分落在何处。
1.1均值：
算术平均
调和平均
几何平均
截尾平均（为抵消少数极端值的影响，放弃高低极端后的均值）

1.2中位数

1.3众数

2.数据的散布（离散程度）
2.1极差
2.2四分位数
2.3四分位极差
四分位极差IQR：Q3-Q1（第3个四分位数-第1个四分位数），这个指标可以用于离群点的识别。识别可以的离群点的通常规则是，挑选落在第3个四分位数以上或第1个四分位数之下至少1.5*IOR处的值
2.4五数概括
2.5盒子图
注意盒子图的画法：盒子图会有两个“胡须”，这两个胡须一般是数据集的最小值和最大值，中位数用盒内的线表示；仅当最高和最低观测值超过四分位数不到1.5*IQR时，胡须扩展到它们。否则，胡须在出现在1.5*IOR之内的最极端的观测值处终止。
2.6方差
2.7极差

3.简单数据可视化：
有时候看图会比看变量的指标（如均值，极差）更快的了解数据的分布。下面介绍一些简单常见的统计图
3.1直方图
3.2饼图
3.3线图
3.4分位数图
3.5分位数-分位数图
3.6散点图

4如何度量数据的相似性和相异性
簇：组内相似，组间相异
4.1相似性度量
标称属性：不匹配率（两个属性之间不匹配数目占所有属性数目的比例）
二元属性：相异性分为对称的二元属性和非对称的二元属性，对于对称的而言，每个状态都是同等重要，故相异性的度量就是用两个的差别部分数目与总数目之比来表示，而非对称的，两个状态不是同等重要，两个取值为1的状态比两个取值为0的情况更急有意义。负匹配数被认为是不重要的，不考虑在分母内，其他一样。对非对称的二元属性，相似性就用1减去相异性即可，称为Jaccard系数。

4.2数值属性的相异性度量：明氏距离，欧氏距离，曼哈顿距离，切比雪夫距离，马氏距离
序数属性的邻近性度量（属性有顺序优劣之分）
余弦相似性、Tanimoto距离
适用于稀疏性的数据（有多个0）

二、数据预处理
数据质量：准确性，完整性，一致性，时效性，可信性，可解释性
上面介绍了一些初步了解数据的方法手段，下面总结下数据预处理。
数据预处理主要分为四个步骤：数据清洗，数据集成，数据归约，数据变换
1.数据清洗：主要为了填补缺失值，光滑噪声数据，识别或删除离群点
1.1缺失值：
忽略元组，人工填写，用全局常量填充，用属性的均值填充等
1.2噪声数据（被测量的变量的随机误差或方差）：
分箱：通过考察数据的“近邻”来光滑有序数据值，有等频箱，箱均值光滑，箱边界光滑
回归：用一个函数拟合数据来光滑数据
1.3离群点：如何识别离群点以及如何处理离群点
数据清洗的第一步是偏差检测，导致偏差的因素可能有很多种
2.数据集成：数据来自多个数据源，属性在不同的数据库有不同的名字，不一致性
2.1实体识别问题：如何判断不同的数据库的不同列名是否是同一个变量，空值，0值，缺失值等。
2.2冗余和相关分析：若一个属性能优另一个或另一组属性导出，则这个属性可能是冗余的。属性或维命名的不一致也可能导致结果数据集中的冗余。有些冗余可被相关分析检测到。标称数据，使用卡方检验；数值属性，用相关系数，协方差，评估一个属性的值如何随另一个变化。
3.数据归约：维归约和数值归约。
3.1维归约
使用数据编码方案，使原始数据压缩简化，数据压缩（小波分析，PCA，数据压缩分有损和无损的），属性子集选择（去掉不相关属性），属性构造（从原来的属性集导出更有用的小属性集）。
3.2数值归约
用参数模型（回归和对数线性模型）或非参数模型（直方图，聚类，抽样，数据聚集），用较小的表示取代数据
3.2.1小波变换：略
3.2.2主成分分析：搜索k个最能代表数据的n维正交向量，k小于n，原始数据投影到一个小得多的空间上，导致维归约。PCA通过创建一个替换的，较小的变量集“组合”属性的基本要素。
3.3特征子集选择
属性子集的选择【特征子集选择】：（因为漏下相关属性或留下不相关属性都是有害的，可能导致发现质量很差的模式）删除不相关或冗余的属性（维）减少数据量。目标是找出最小属性集，使得数据类的概率分布尽可能的接近使用所有属性得到的原始分布。

3.3.1逐步向前选择：由空属性集开始，确定原属性集中最好的属性，将其加到归约集中，在之后的迭代中，将剩下的原属性集中最好的属性加到归约集中。

3.3.2逐步向后删除：由整个属性集开始。在每一步中，删除尚在属性集中最差的属性
逐步向前选择和逐步向后删除的组合：每一步选择一个最好的属性，并在剩余属性中删除一个最差的属性。
3.3.3决策树归纳：由给定的数据构造决策树，不出现在树中的所有属性假定是不相关的，出现在树中的属性形成归约后的属性子集
属性构造【特征构造】：如长乘宽得到面积
回归：

直方图：单个值->单值桶。如何确定桶和属性值的划分？
等宽：每个桶的宽度区间一致
等频（等深）：使得每个桶的频率粗略的为常数（即每个桶大致包含相同个数的邻近数据样本）
对于近似稀疏和稠密数据，以及高倾斜和均匀数据，直方图非常有效。对于存放具有高频率的离群点，单值桶是有用的
聚类：簇和簇的质量的度量
抽样：无放回简单随机抽样，有放回简单随机抽样，簇抽样，分层抽样
4.数据变换：规范化，数据离散化和概念分层
光滑：去掉数据中的噪声，分箱，回归，聚类
属性构造：由给定的数据属性创建性的属性并添加到属性集中。
聚集：对数据进行汇总或聚集
规范化：把属性数据按比例缩放，使之落入一个特定的小区间。最小-最大规范化，z分位数规范化，按小数定标规范化
分箱离散化：是一种基于指定的箱个数的自顶向下的分裂技术
  """,

  """
 1.1 项目摘要  
     传统办法管理信息首先需要花费的时间比较多，其次数据出错率比较高，而且对错误的数据进行更改也比较困难，最后，检索数据费事费力。因此，在计算机上安装网上商品订单转手系统软件来发挥其高效地信息处理的作用，可以规范信息管理流程，让管理工作可以系统化和程序化，同时，网上商品订单转手系统的有效运用可以帮助管理人员准确快速地处理信息。

     网上商品订单转手系统在对开发工具的选择上也很慎重，为了便于开发实现，选择的开发工具为idea，选择的数据库工具为Mysql。以此搭建开发环境实现网上商品订单转手系统的功能。其中管理员管理用户，新闻公告。

     网上商品订单转手系统是一款运用软件开发技术设计实现的应用系统，在信息处理上可以达到快速的目的，不管是针对数据添加，数据维护和统计，以及数据查询等处理要求，网上商品订单转手系统都可以轻松应对。

1.2 目的意义：
       网上商品订单转手系统可以对网上商品订单转手系统信息进行集中管理，可以真正避免传统管理的缺陷。网上商品订单转手系统是一款运用软件开发技术设计实现的应用系统，在信息处理上可以达到快速的目的，不管是针对数据添加，数据维护和统计，以及数据查询等处理要求，网上商品订单转手系统都可以轻松应对。所以，网上商品订单转手系统的运用是让网上商品订单转手系统信息管理升级的最好方式。它可以实现信息处理的便利化要求，还可以规范信息处理的流程，让事务处理成为管理人员手中的一件简单事，而不是之前手工处理时的困难事。尽管网上商品订单转手系统具备较完善的功能，但是也需要管理人员利用闲暇时间提升自身素质以及个人能力，在操作网上商品订单转手系统时可以最大化运用网上商品订单转手系统提供的功能，让系统在满足高效率处理数据的同时，也能始终稳定运行，还可以确保数据的可靠性与数据处理的质量。

二、主要技术： 
2.1  Spring Boot框架：
        Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。

SpringBoot基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。

2.2 Tomcat：
        刚开始学习Java语言的时候，是不知道还有Tomcat这些东西的，各种语法各种输出在控制台进行输出结果，当Java网站开发的时候就不可避免的学习到了Tomcat服务器。Tomcat准确的来讲不算是服务器，可以说是vue引擎或者一个容器，这些都是学术上或者原理上都比较贴切的，但是实际工作中Tomcat就是作为一个web服务器来用的，因为可以实现网站的发布和运行。因为工作原理的原因，Tomcat一般作为中小型企业和并发量并不突出的一种轻量级的服务器存在的，比如某些行业的应用系统，本身客户端就不多，需要的连接也不多，一般都用Tomcat的。Tomcat里面可以配置多个网站，配置文件后缀是config的文档，类似于XML的结构，比较清晰明了。每当Java发布新的版本的时候，Tomcat也会为了匹配Java的版本进行升级，目前Tomcat版本已经到版本10了。Tomcat标识是一只有点发黄的小猫咪，当Tomcat配置成功一般测试的时候能看到这个小猫咪就算是成功的，才能进行下一步的配置。Tomcat服务器在Java网站开发中还是挺合适的。

2.3 Springboot
   Java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点：复杂的配置，项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。一个是混乱的依赖管理。项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。而SpringBoot让这一切成为过去！Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。我们可以使用SpringBoot创建java应用，并使用Java–jar 启动它，就能得到一个生产级别的web工程

三、系统设计：
3.1 系统功能设计：
网上商品订单转手系统主要功能设计：

主要角色：用户 商家 管理员

主要功能设计：用户登录、注册、修改密码、首页信息展示、系统轮播图  、模糊搜索、收藏、商品点击数量统计、评论、收藏、富文本图文上传、文件上传、商家管理、用户余额充值等

商品管理（订单、商品评论、回复、商品统计报表、接单、转单、发货、收货、退货等）

公告信息、加上一些基本业务功能的添加修改删除操作等
  """
];


List<String> themes = [
  '探索新技术：从头开始学习',
  '为你的代码库添加自动化测试',
  '最佳代码实践：如何编写干净、可维护的代码',
  '管理复杂的代码库：使用 Git 的高级技巧',
  '如何减少应用程序的错误和崩溃',
  '构建高性能的分布式系统',
  '全面了解 Web 开发中的前沿技术',
  '数据结构与算法：提高代码效率的秘诀',
  '了解机器学习的基础知识',
  '从头学习深度学习：理论与实践',
  '如何构建安全的 Web 应用程序',
  '了解云计算的基础知识',
];

List<String> comments = [
  '这个主题很有趣！',
  '感谢分享这么有价值的文章。',
  '我学到了很多新知识。',
  '讲解得非常清晰，易于理解。',
  '非常好的技术分享。',
  '希望有更多的实战案例。',
  '非常感谢你的精彩分享。',
  '这篇文章对我帮助很大。',
  '非常棒的内容！',
  '简单易懂，通俗易懂。',
  '讲得真是太好了，连我这个小白都听懂了。',
  '非常期待你的下一篇文章。',
  '这个主题真的很实用。',
  '非常鼓励你继续分享你的知识。',
  '这篇文章让我受益匪浅。',
  '非常喜欢这篇文章的风格。',
  '写得非常不错，期待更多。',
  '我还需要更多这样的文章。',
  '非常感谢你的详细讲解。',
  '你的文章让我欲罢不能。',
];



String geneTitle() {
  Random random = Random();
   return themes[random.nextInt(themes.length)];
}

List<String> geneComments() {
  Random random = Random();
  int count = random.nextInt(15) + 1;
  List<String> list = [];
  for (int i = 0; i < count; i++) {
    list.add(comments[random.nextInt(comments.length)]);
  }
  return list;
}
String geneContent() {
  Random random = Random();
  int count = random.nextInt(10) + 1;
  String content = '';
  for (int i = 0; i < count; i++) {
    content += contents[random.nextInt(contents.length)];
  }
  return content;
}




String geneEssay() {
  List<String> sentenceStarts = [
    '在现代社会中，信息技术功不可没。',
    '当我们看到网络上流传的各种有趣的应用程序时，',
    '软件开发已经成为现代社会中最为重要的行业之一。',
    '云计算技术改变了我们生活的方式，',
    '在过去的几年里，人工智能技术取得了长足的进步，',
    '在移动端技术越来越成熟的今天，',
    '现代软件开发的复杂度越来越高，',
    '人们在游戏中得到的乐趣越来越多，',
    '随着微服务架构的普及，',
    '在现代软件开发中，架构设计已成为关键。',
  ];

  List<String> sentenceMiddles = [
    '今天，我们开发的应用程序在各个领域中扮演着重要角色，',
    '我们会意识到软件开发过程中的挑战和机遇，',
    '每天都会涌现出许多新兴的软件公司，',
    '使得我们可以更加高效、便捷的获取信息和资源，',
    '各领域的专家都在不断探索人工智能在各个领域的应用，',
    '我们需要加强对移动端技术的学习和研究，',
    '我们可以通过使用各种现代工具来简化这一过程，',
    '现代游戏开发人员需要花费更多的精力在游戏性和表现上，',
    '微服务架构可以帮助我们摆脱复杂的传统架构，',
    '构建高质量的架构是开发人员最重要的任务之一。',
  ];

  List<String> sentenceEnds = [
    '这是一个真正充满挑战，但又充满乐趣的时代。',
    '软件开发行业将会迎来更好、更有趣的未来。',
    '在这个竞争激烈的市场中，我们需要保持创新和创造力。',
    '从而为我们的生产生活创造更多的可能性。',
    '我们可以预见未来软件技术将会如何改变我们的生活。',
    '软件开发行业已经成为现代社会中最为引人注目的行业之一。',
    '这是一个颇具挑战性和机遇的时代。',
    '我们需要不断通过学习和创新来应对不断变化的市场需求。',
    '通过使用各种工具和技术，我们可以更加高效地完成软件项目。',
    '我们需要不断寻找创新的架构设计和开发方式，以应对未来的挑战。',
  ];

  Random random = Random();

  return '${sentenceStarts[random.nextInt(sentenceStarts.length)]}'
        '${sentenceMiddles[random.nextInt(sentenceMiddles.length)]}'
        '${sentenceEnds[random.nextInt(sentenceEnds.length)]}';
}


//! 生成随笔
List<Post_essay> generatePost_essay(int count) {
  Random random = Random();
  List<String> imageUrls = [];
  List<Post_essay> posts = [];

  for (int i = 0; i < count; i++) {
    int randomImageCount = random.nextInt(9) + 1;
    List<String> images = List.generate(randomImageCount,
            (index) => 'https://www.itying.com/images/flutter/${random.nextInt(6) + 1}.png');
    Post_essay post = Post_essay(
      author: "作者 ${i + 1}",
      publishTime: "${2 * (i + 1) + random.nextInt(2)}小时前",
      content: geneEssay(),
      images: images,
    );
    posts.add(post);
  }

  return posts;
}